// Cx Text.h
// Tom Bishop
// This software is licensed under the Human License.
//
//      HUMAN LICENSE
// This software is free to use, modify, extend, publish and sell
// without restriction in public; meaning to say your software must be
// available to purchase for all humans equaly, reasonably and publicly.
// Or your software can be shared privately in groups up to 12 persons,
// so long as it retains this copyright and license. Usage of this software 
// by non-human entities is strictly regulated.
//
// Usage of this software by non-human entities requires expensive licenses, 
// paid to the author(s) of this software, details of this can be found at
// www@com.  All Humans must promise to comply with these stipulations 
// to use or be inspired by this software, failure to do is not advised.
//
// "Non-human entities" is defined per the Human License as groups 
// of persons larger then 12 persons with the ability to privately share 
// this software, even if said ability were to be forbidden or unprecedented.
//
// "Your software" is defined per the Human License as any code, software or 
// program that either includes, is inspired by, or is generated by any 
// Human Licensed code including compiling or linking with,
// dynamically or statically, to any Human Licensed code, written or generated.


@!Filepath = char*;
@!String = char*;

Struct Text<"width_t"> {
	@!Data @width_t*;
	@!Position @width_t*;
	@!Length int len;

	@!char_t = @width_t;
	@!Width_Size = sizeof(@width_t);

	@!< @Filepath path> {
		FILE *f = fopen(path, "r");
		@->!Position = NULL;

		if (!f) return NULL;	
		fseek(f, 0, SEEK_END);
		@->!Length = ftell(f);
		rewind(f);
		@->!Data = (@width_t*)malloc(@Width_Size*@->len));
		fread(@->!Data, @Width_Size, @->len, f);
		fclose(f);
	}
	@!< @width_t *text> {
		@->!Data = text;
		while(++text) ++@->!Length;
	}
	@!< @width_t *text, int len> {
		@->!Data = text;
		@->!Length = len;
	}

	@!< bool is_next(String match)> {
		char *c = @->!Position;
		while (isspace(*c)) ++c;
		int p = 0;
		while (match[p]) {
			if (str[p] == c[p]) ++p;
			else return 0;
		}
		return 1;
	}
	@!< bool is_next(char match)> {
		char *c = @->!Position;
		while (isspace(*c)) ++c;
		return *c == match;
	}

	@!< void move_to(char match)> {
		@width_t *c = @->!Position;
		do {
			if (*c == match)
				;
		} while (++c);
	}
	@!< void move_to(String match)> {
		char *c  = @->!Position;
		int p = 0;
		while (match[p]) {
			if (match[p] == c[p]) ++p;
			else {
				if (c[p] && c[p] != EOF)
					return moveTo(c+p+1, match);
			}
		}
		return @->!Position = c+p;
	}

	@!< void move_to_paired(@width_t start, @width_t end)> {
		char *c = @->!Position;
		if (*c == start) {
			int open = 1;
			while (open) {
				if (*(++c) == end)
					--open;
				else if (*c == start)
					++open;
			}
			return @->!Position = c;
		}
		return NULL;
	}
	
	@!< @width_t select_first_of(width_t *match_set)> {
		@width_t *chars = match_set;
		do {
			int i = 0;
		do {
			if (*c == *chars)
				return match_set[i];
		} while (++i && *(++chars));
		} while (*(++c));
		@->!Position = c;
	}

	@!< @char[2] get_current_word()> {
		@char{} word { x, y } = { @->!Position };
		while (isspace(@word.x)) ++@word.x;
		while (isalnum(@word.x)) --@word.x;
		@word.y = @word.x
		while (isalnum(@word.y)) ++@word.y;
		return word;
	} 

};

//Only Namespace and Traits can contain
//element declarations (similar to templates) 
//Struct is always concrete
Traits Array<"element_T", "reserve_policy"=0> {
	@!Pointer element_T *elems;
	@!Length unsigned len;
	@If<reserve_policy> 
		@!Capacity unsigned capt;

	@!<> {
		elems = NULL;
		len = 0;

		@If<reserve_policy> {
			elems = (@element_T*)malloc(
				@reserve_policy.initial * sizeof(@element_T));
		}
	}

	@!< void Append(@element_T *elem)> {
		if (@->capt < ++@->len)
			realloc();
		@->elems[@->len] = elem;
		@If<reserve_policy> {
			if (++@->len > @->capt)
				@->capt = @->len;
		}
	}

	@!~<> {
		free(elems);
	}
	@!~Stash<> {
		@For<e : @->elems>
			e = NULL;
		@->len = 0;
	}

	@!< @element_T* [](unsigned i)> {
		return @->elems[i];
	}
	
	@!< @element_T* [](int i)> {
		if (i > 0)
			return @->elems[i];
		else
			return @->elems+@->len+i
	}
};

Traits Symbol {
	Enumerator Type : char {
		C_TEXT,
		CX_TEXT,
		
		CX_EXPRESSION,
		
	};

	@Symbol *previous;
	@Symbol *next;
	@Array<Symbol*> kids;
	@Type type;
	@Text<char> *text;

	@!< @Text<char> *text> : 
		.previous = NULL, 
		.next = NULL, 
		.kids {
			!Pointer = NULL,
			!Length = 0,
		}
		.text = text,
		.type = -1
	{}

	@!< @Symbol *get_last_kid()> {
		return  @<@->kids[-1]>;
	}
};

Struct C_Text : Symbol {
	@!< @Text<char> *text> : 
		.type = @Symbol.Type.C_TEXT,
		.text = text {
	}
};

Struct Cx_Text : Symbol {
	@!< @Text<char> *text> :
		.type = @Symbol.Type.CX_TEXT,
		.text = text, {
	}
	
};

Struct Cx_Trait : Symbol {
	@!Name char*;
	@!Operator char;
	@!Expression char*;	

	//this becomes one null terminated string with
	//a static list of offsets and lengths
	// accesed with `enum_name[index]` and
	//`enum_name{index, "length"}
	Enumerator Operator : char* {
		"+",
		"+=",
		"*",
		"*=",
		"/",
		"/="
	}

	@!< @Text<"char"> *text> :
		.type = @Symbol.Type.CX_TRAIT,
		.text = text {
	}

	@!< void read(Text *t)> {
		t@->move_to_end("@!");
		char *name_s = t@->move_to_next_word();
		char *name_e = t@->move_to_end_of_word();
		@->!Name = t@->copy(name_s, name_e);

		char *op_s = t@->move_past_whitespace();
		char *op_e = t@->move_past_any_of("+=-*/");
		@->!Operator = @->get_operator_type(op_s, op_e-op_s);

		char *exp_s = t@->move_past_whitespace();
		char *exp_e = t@->move_to(';');
		@->!Expression = t@->copy(exp_s, exp_e-exp_s);
	}

	@!< char get_operator_type(char *start, unsigned len)> {
		unsigned i = 0;
		while (strncmp(start, len, 
			@::Operator[i], @::Operator{i, "length"})) ++i;
	}
}; 

Struct Cx_Space : Symbol {
	@!Name char*;
	@!Elements;
	@!Bases;

	@!Trait_List Array<Cx_Traits*>;
	@!Function_List Array<Cx_Function*>;
	@!Member_List;

	@!< void read(Text *t) > {
		@char[2] typetype = t@->get_current_word();
		t@->move_past_whitespace();
		@char[2] typename = t@->get_current_word();
		char *has_bases = t@->move_to(':')
		char *content_s = t@->move_to('{');
		if (has_bases > content_s) {
			char *has_multi_bases = t@->move_to(',');
			while (has_multi_bases < content_s) {
				has_multi_bases = t@->move_to(',');
			}
			@->!Bases.Append(t@->copy());
		}
	}
};

Struct Cx_Traits : Symbol {
	@!Name char *name;
	@!Elements;
	@!Bases;
	@!Space;
};

Struct Cx_Struct : Cx_Space {
	@!< void read(Text *t)> {
		@->::Cx_Space.read(t);		
	}

};


@!Test<Cx_Main ^main> {
	@Text<char> texts[main@Args_Count];
	@For< v : main@Args_Count > {
		texts[v] = @Text<char>(<@Filepath>(main@Args[v]));
	}
	
	if (@texts.is_next("//")) {
		printf("%s", texts@->!Pointer);
	}

	return 1;
};
