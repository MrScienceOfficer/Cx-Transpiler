// Cx Transpiler for The Standard C Compiler.
// Tom Bishop
// This software is licensed under the Human License.
//
//      HUMAN LICENSE
// This software is free to use, modify, extend, publish and sell
// without restriction in public; meaning to say your software must be
// available to purchase for all humans equaly, reasonably and publicly.
// Or your software can be shared privately in groups up to 12 persons,
// so long as it retains this copyright and license. Usage of this software 
// by non-human entities is strictly regulated.
//
// Usage of this software by non-human entities requires expensive licenses, 
// paid to the author(s) of this software, details of this can be found at
// www@com.  All Humans must promise to comply with these stipulations 
// to use or be inspired by this software, failure to do is not advised.
//
// "Non-human entities" is defined per the Human License as groups 
// of persons larger then 12 persons with the ability to privately share 
// this software, even if said ability were to be forbidden or unprecedented.
//
// "Your software" is defined per the Human License as any code, software or 
// program that either includes, is inspired by, or is generated by any 
// Human Licensed code including compiling or linking with both
// dynamically anyd statically to any Human Licensed code, written or generated.

//#define PY_SSIZE_T_CLEAN
//#include <Python.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#define DEBUG_TEXT
#include "Text.h"

#define DEBUG_SYMBOL(sym) printf("%s %s %i\n", __func__, (sym)->name, (sym)->type);
#define DEBUG_SYMBOL_SHOW_TEXT(sym) DEBUG_SYMBOL(sym);\
       	print_line((sym)->text.ptr, (sym)->text.len, "Symbol")

char Struct[] =  "Struct";
char Class[] = "Class";
char Traits[] = "Traits";
char Namespace[] = "Namespace";


enum {
	CX_C,	
	CX_EXPRESSION,
	
	CX_ELEMEMT,
	CX_ARGUEMENT,
	CX_FUNCTION,

	CX_TRAIT,

	CX_NAMESPACE,
	CX_TRAITS, 
	CX_STRUCT,
	CX_CLASS
};

struct Arguement{
//	PY_ObjectHead

   char *name;
	char *val;
	char *def;
};

//Node in the token graph
typedef struct {
	int type;
	char *name;

	struct Symbol *next;
	struct Symbol *prev;
	struct Symbol *kids;
	struct Symbol *parent;
	
	struct Text raw_text;
} Symbol;

Symbol *getLastChild_Symbol(Symbol *parent) {
	Symbol *k = parent->kids;
	if (k) 
		while (k->next)
		  	k = k->next;
	return k;
}

typedef struct {
	Symbol sym;
} C_Text;
typedef struct {
	Symbol sym;	
} Cx_Text;

typedef struct {
	Symbol sym;
	char *name;
	char operator;
	Cx_Text cx_text;
} Cx_Trait;

//symbol for the subsitute element
//declaration
typedef struct {
	Symbol sym;
} Cx_Element;


//symbol for functions
typedef struct {
	Symbol sym;

	Expression ret_exp;
	Element elems_list;
	Expression args_list;
	Expression code;
} Function;

//!@ trait
typedef struct {
	Symbol sym;

	Element elems_list;
	Expression code;
} Trait;

//Block of type, function, and member traits
typedef struct {
	Symbol sym;

	Element elems_list;
	Function funcs_list;
	Trait traits_list;
} Traits;

typedef struct {
	Symbol sym;

	Element elems_list;
	Function funcs_list;
	Trait traits_list;
} Struct;

typedef struct {
	Symbol sym;

	Element elems_list;
	Function funcs_list;
	Trait traits_list;
} Class;

typedef struct {
	Symbol sym;

	Trait trait_list;
	Traits traits_list;
	Function funcs_list;
	Struct structs_list;
} Namespace;


Symbol *createNext_Symbol(Symbol *parent, int sym_id, 
		char *start, int len,  char *name) {
	Symbol *sym;
	switch(sym_id) {
	case CX_C:
		sym = (Symbol*)malloc(sizeof(C_Code));
		break;
	case CX_EXPRESSION:
		sym = (Symbol*)malloc(sizeof(Expression));
		break;/*
	case CX_ELEMEMT:
		sym = (Symbol*)malloc(sizeof(Element));
		break;
	case CX_ARGUEMENT:
		sym = (Symbol*)malloc(sizeof(struct Arguement));
		break;*/
	case CX_FUNCTION:
		sym = (Symbol*)malloc(sizeof(Function));
		break;
	case CX_TRAIT:
		sym = (Symbol*)malloc(sizeof(Trait));
		break;
	case CX_NAMESPACE:
		sym = (Symbol*)malloc(sizeof(Namespace));
		break;
	case CX_TRAITS:
		sym = (Symbol*)malloc(sizeof(Traits));
		break;
	case CX_STRUCT:
		sym = (Symbol*)malloc(sizeof(Struct));
		break;
	}
	sym->prev = sym->next = sym->kids = NULL;
	sym->parent = parent;
	sym->type = sym_id;
	sym->name = name;

	init_Text(&sym->text, start, len);
	
	Symbol *last_kid = getLastChild_Symbol(parent);
	if (last_kid) {
		last_kid->next = sym;
		sym->prev = last_kid;
	}
	else {
		parent->kids = sym;
		sym->prev = NULL;
	}

	DEBUG_SYMBOL(sym);
	return sym;
}

char *create_Ccode(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	if (isNext_str(c, "//") || isNext_char(c, '#')) {
		//this shoudl be like
		//while (end = moveTo_char(c, '\n') && *end-1 == "\\")
		//		c = end + 1; move past last \n and keep going
		char *end = moveTo_char(c, '\n');
		C_Code *c_code = createNext_Symbol(parent, CX_C, c, end-c, NULL);
		return end;
	}
	/* mutli line comment */
	if (isNext_str(c, "/*")) {
		char *close;
		if (close = moveTo_str(c, "*/")) {
			C_Code *c_code = createNext_Symbol(parent, CX_C, c, close-c, NULL);
			return close;
		}
	}
	//we need errror reporting
	return c;
}

char *read_Elements(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	char *has_elems = moveTo_char(c, '<');
	char *has_bases = moveTo_char(c, ':');
	char *contents_s = moveTo_char(c, '{');
	if (!(has_elems < has_bases && has_elems < contents_s)) {
		return c;
	}
	char *start = has_elems;
	char *end = moveToPaired_char(start, '<', '>');
	int elems = count_char(start, end, ',');
	char *start_elm = start;
	char *end_elm;
	int cnt = 0;
	do {
		start_elm = moveTo_char(start_elm, '"');
		end_elm = moveToPaired_char(start_elm, '"', '"');
		print_line(start_elm, end_elm-start_elm, "Element");
		start_elm = end_elm+1;
	} while (++cnt <= elems);
	return end;
}

char *read_Bases(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	char *has_bases = moveTo_char(c, ':');
	char *end = moveTo_char(c, '{');
	if (has_bases > end) {
		return c;
	}
	c = has_bases;
	int bases = count_char(c, end, ',');
	char *base = c;
	int cnt = 0;
	do {
		char *base_e = moveToEndOfNextWord(base);
		print_line(base, base_e-base, "Base");
		base = base_e+1;
	} while (++cnt <= bases);
	return c;
}

char *read_CxContents(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	c = moveTo_char(c, '{');
	char *end = moveToPaired_char(c, '{', '}');
	print_line(c, end-c, "Cx contents");
	return end;
}

char *create_Namespace(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	char *start = moveTo_char(c, '{');
	char *end;
	end = moveToPaired_char(start, '{', '}');

	char *name_start = moveTo_char(c, ' ');
	while (isspace(*(++name_start)));
	char *name_end = name_start;
	while (isalnum(*(++name_end)));

	Namespace *ns = createNext_Symbol(parent, CX_NAMESPACE, 
			start+1, end-start-1, copy_line(name_start, name_end-name_start));

	c = read_Elements(ns, c);
	c = read_Bases(ns, c);
	c = read_CxContents(ns, c);

	//Read Nested Namespace Source
	Read_Cx(ns);
	return end;
}

char *create_Trait(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	c = moveTo_str(c, "@!");
	char *name_end = c+1;
	while (isalnum(*(++name_end)));

	Trait *trait;
	char *end = 0;
	if (end = moveTo_char(c, ';')) {
		trait = createNext_Symbol(parent, 
				CX_TRAIT, c, end-c, copy_line(c, name_end-c));
	}
	return end;
}

char *create_Cx___(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	if (isNext_str(c, "@If<"));
	else if (isNext_str(c, "@Elif<"));
	else if (isNext_str(c, "@Else<"));
	else if (isNext_str(c, "@Include<")) {
		c = moveTo_char(c, '<');
		char *end = moveToPaired_char(c, '<', '>');
		return end;
	}
	else if (isNext_str(c, "@For<"));
	else if (isNext_str(c, "@While<"));
	else if (isNext_str(c, "@Do<"));
	else if (isNext_str(c, "@<>"));
	else if (isNext_str(c, "@<")) {
		c = moveTo_char(c, '<');
		char *end;
		end = moveToPaired_char(c, '<', '>');
		if (end) {
			print_line(c, end-c, "func");
			//read elements
		}
		return end;
	}
	else { 
		char *word = c;
		while (isalnum(*(++word)) || *word == '_' || *word == '.');
	//	print_line(c, word-c, "@@");
	}
	return c;
}

char *create_Function(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	c = moveTo_str(movePast_str(c, "@!<"), "@!");
	char *sig_parts = moveToPaired_str(c, '<', '>');
	print_line(c, sig_parts-c, "Signature");
	char *body_s = moveTo_char(c, '{');
	char *body_e = movePairedTo_char(c, '{', '}');
	
	return
}

char *create_Traits(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	c = movePast_str(moveTo_str(c, Traits), Traits);
	while (isspace(*(++c)));
	
	char *name_s = c;
	while (isalnum(*c) || *c == '_' || *c == ':') ++c;
	char *name_e = c;

	char *cx_s = moveTo_char(c, '{');
	char *cx_e = moveToPaired_char(cx_s, '{', '}');
	if (cx_e) return c;

	Traits *traits = createNext_Symbol(parent, CX_TRAITS,
		cx_s, cx_e-cx_s, copy_line(name_s, name_e-name_s));
	
	c = read_Elements(traits, c);
	c = read_Bases(traits, c);
	c = read_CxContents(traits, c);

	return cx_e;
}

char *create_Struct(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	c = movePast_str(moveTo_str(c, Struct), Struct);
	while (isspace(*(++c)));
	
	char *name_s = c;
	while (isalnum(*c) || *c == '_' || *c == ':') ++c;
	char *name_e = c;

	char *cx_s = moveTo_char(c, '{');
	char *cx_e = moveToPaired_char(cx_s, '{', '}');
	if (!cx_e) return c;

	Struct *structs = createNext_Symbol(parent, CX_STRUCT,
		cx_s, cx_e-cx_s, copy_line(name_s, name_e-name_s));
	
	c = read_Elements(structs, c);
	c = read_Bases(structs, c);
	//char *contents =;
	c = read_CxContents(structs, c);

	return cx_e;
}

char *create_Class(Symbol *parent, char *c) {
	DEBUG_SYMBOL(parent);
	c = movePast_str(moveTo_str(c, Class), Class);
	while (isspace(*(++c)));
	
	char *name_s = c;
	while (isalnum(*c) || *c == '_' || *c == ':') ++c;
	char *name_e = c;

	char *cx_s = moveTo_char(c, '{');
	char *cx_e = moveToPaired_char(cx_s, '{', '}');
	if (!cx_e) printf("ERROR");

	Class *class = createNext_Symbol(parent, CX_CLASS,
		cx_s, cx_e-cx_s, copy_line(name_s, name_e-name_s));
	
	c = read_Elements(class, c);
	c = read_Bases(class, c);
	//char *contents =;
	c = read_CxContents(class, c);

	return cx_e;
}

void Read_Cx(Symbol *root) {	
	DEBUG_SYMBOL(root);
	char *c = root->text.ptr;

	do {
		//one line comments and compiler directives
		/* mutli line comment */
		if (isNext_str(c, "//") || isNext_char(c, '#') || isNext_str(c, "/*")) {
			c = create_Ccode(root, c);
		}
		if (isNext_str(c, "@!")) {
			//check for function declare type.
			char *capture;
			if (isNext_pat(c, "@!*<", capture)) {
				if (strcmp("Final", capture 
							|| strcmp("Override", capture))) {
					c = create_Function(root, c);
				}
			}
			//Trait
			c = create_Trait(root, c);
		}
		//@ Cx transpiler directives
		if (isNext_char(c, '@')) {
			c = create_Cx___(root, c);
		}
		if (isNext_str(c, "Namespace")) {
			c = create_Namespace(root, c);
		}
		if (isNext_str(c, "Traits")) {
			c = create_Traits(root, c);
		}
		if (isNext_str(c, "Struct")) {
			c = create_Struct(root, c);
		}
		if (isNext_str(c, "Class")) {
			c = create_Class(root, c);
		}
	} while (*(++c) && c < root->text.ptr+root->text.len);
}

void Write_C(Symbol *global, char *out_path) {
	DEBUG_SYMBOL(global);
	Symbol *sym_gr = global->kids;
	while (sym_gr = sym_gr->next) {
		printf("%s:%i  \n", sym_gr->name, sym_gr->type);
		Symbol *kid = sym_gr->kids;
		if (kid) {
			Symbol *p = kid;
			while (p->parent) {
				p = p->parent;
				printf("%s:%i \n", p->name, p->type);	
			}
			printf("	%s:%i  \n", kid->name, kid->type);
			kid = kid->next;
		}
	}
}

void Free_Cx(Symbol *global) {
	DEBUG_SYMBOL(global);
	free(global->text.ptr);
}

struct Text open_CxFile(char *path) {
	return create_Text_filepath(path);
}

void set_CxGlobal(Symbol *cx_global, char *main_src) {
	DEBUG_SYMBOL(cx_global);
	cx_global->name = "@";
	cx_global->type = CX_NAMESPACE;
	cx_global->kids = NULL;
	cx_global->next = NULL;
	cx_global->prev = NULL;
	cx_global->parent = NULL;
	cx_global->text = open_CxFile(main_src);
	if (!cx_global->text.ptr) return 0;

}

int main(int argc, char **argv) {
	Namespace cx_global;
	set_CxGlobal(&cx_global, argv[1]);

	Read_Cx(&cx_global);
	Write_C(&cx_global, "file");
	Free_Cx(&cx_global);

	return 1;
};



