// Cx Text.h
// Tom Bishop
// This software is licensed under the Human License.
//
//      HUMAN LICENSE
// This software is free to use, modify, extend, publish and sell
// without restriction in public; meaning to say your software must be
// available to purchase for all humans equaly, reasonably and publicly.
// Or your software can be shared privately in groups up to 12 persons,
// so long as it retains this copyright and license. Usage of this software 
// by non-human entities is strictly regulated.
//
// Usage of this software by non-human entities requires expensive licenses, 
// paid to the author(s) of this software, details of this can be found at
// www@com.  All Humans must promise to comply with these stipulations 
// to use or be inspired by this software, failure to do is not advised.
//
// "Non-human entities" is defined per the Human License as groups 
// of persons larger then 12 persons with the ability to privately share 
// this software, even if said ability were to be forbidden or unprecedented.
//
// "Your software" is defined per the Human License as any code, software or 
// program that either includes, is inspired by, or is generated by any 
// Human Licensed code including compiling or linking with both
// dynamically anyd statically to any Human Licensed code, written or generated.

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <regex.h>

void print_line(char *line, int len, char *name) {
        char t[len+1];
        memmove(t, line, len);
        t[len] = NULL;
        printf("%s: %s \n", name, t);
}

#define DEBUG_ENTER_(arg) _Generic((arg),\
char:printf("%s : '%c'\n", __func__, arg),\
char*:printf("%s :\"%s\"\n", __func__, arg),\
int:printf("%s : %i\n", __func__, arg))

#ifdef DEBUG_TEXT
#define DEBUG_ENTER(arg) DEBUG_ENTER_(arg)
#else 
#define DEBUG_ENTER
#endif

struct Text {
        char *ptr;
        int len;
};

struct Text create_Text_filepath(char *path) {
        FILE *f = fopen(path, "r");
        struct Text text;
        text.ptr = NULL;

        if (!f) {
                printf("No .cx file to read.");
                //howw can you not know what the
                //function to exit the program is?
                return text;
        }
        fseek(f, 0, SEEK_END);
        text.len = ftell(f);
        rewind(f);
        text.ptr = (char*)malloc(sizeof(char)*text.len);
        fread(text.ptr, sizeof(char), text.len, f);
        fclose(f);

        return text;
}

void init_Text(struct Text *to, char *start, int len) {
        to->ptr = start;
        to->len = len;
}


bool isNext_str(char *c, char *str) {
        DEBUG_ENTER(str);
        //eat white space
        while (isspace(*c)) ++c;
        int p = 0;
        while (str[p]) {
                if (str[p] == c[p])
                        ++p;
                else return 0;
        }
        return 1;
}

bool isNext_char(char *c, char match) {
        DEBUG_ENTER(match);
        while (isspace(*c)) ++c;
        return *c == match;
}

bool isNext_pat(char *c, char *match, int captures) {
	//read pattern
	regex_t regex;
	int res = regcomp(&regex, match, 0);
	printf("regex : %c", res);
	regmatch_t next[captures+1];
	regexec(&regex, c, captures, next, 0);

	regfree(&regex);

	//eat white space
        while (isspace(*c)) ++c;
        int p = 0;
        while (str[p]) {
                if (str[p] == c[p])
                        ++p;
                else return 0;
        }
        return 1;
}

char *moveTo_char(char *c, char find) {
        DEBUG_ENTER(find);
        do {
                if (*c == find)
                        return c;
        } while (++c);
        return NULL;
}

char *moveToPaired_char(char *c, char start, char end) {
        DEBUG_ENTER(end);
        if (*c == start) {
                int open = 1;
                while (open) {
                        if (*(++c) == end)
                                --open;
                        else if (*c == start)
                                ++open;
                }
                return c;
        }
        else {
                printf("c[0] must match start char");
        }
        return NULL;
}

char *moveTo_str(char *c, char *find) {
        DEBUG_ENTER(find);
        int p = 0;
        while (find[p]) {
                if (find[p] == c[p])
                        ++p;
                else {
                        if (c[p] && c[p] != EOF)
                                return moveTo_str(c+1, find);
                        else return NULL;
                }
        }
        return c;
}

char *movePast_str(char *c, char *find) {
        DEBUG_ENTER(find);
        int p = 0;
        while (find[p]) {
                if (find[p] == c[p])
                        ++p;
                else {
                        if (c[p] && c[p] != EOF)
                                return movePast_str(c+1, find);
                        else return NULL;
                }
        }
        return c+p;
}

int count_char(char *c, char *end, char match) {
        int cnt = 0;
        while (c != end) {
                if (*c == match)
                        ++cnt;
                ++c;
        }
        return cnt;
}

char selectFirstOf_char(char *c, char *match_set) {
        DEBUG_ENTER(match_set);
        char *chars = match_set;
        do {
                int i = 0;
        do {
                if (*c == *chars)
                        return match_set[i];
        } while (++i && *(++chars));
        } while (*(++c));
        return EOF;
}
char *moveToNextWord(char *c) {
        DEBUG_ENTER(*c);
        while (!isspace(*c)) ++c;
        while (isspace(*c)) ++c;
        return c;
}

char *moveToEndOfNextWord(char *c) {
        DEBUG_ENTER(*c);
        if (!isalnum(*c))
                c = moveToNextWord(c);
        while (isalnum(*c) || *c == '_' || *c == ':')
                ++c;
        return c;
}

char *copy_line(char *line, int len) {
        char *t = (char*)malloc(len+1);
        memmove(t, line, len);
        t[len] = NULL;
        return t;
}

char *copy_namesymbol(char *c) {
        while (isspace(*c)) ++c;
        char *name = c;
        while (isalnum(*name)) ++name;
        size_t len = name-c;
        char *name_symbol = (char*)malloc(sizeof(char)*(len)+1);
        memmove(name_symbol, c, len);
        name_symbol[len] = NULL;
        return name_symbol;
}

#undef DEBUG_ENTER_
#undef DEBUG_ENTER
