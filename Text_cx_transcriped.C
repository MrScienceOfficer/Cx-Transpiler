// Cx Text.h
// Tom Bishop
// This software is licensed under the Human License.
//
//      HUMAN LICENSE
// This software is free to use, modify, extend, publish and sell
// without restriction in public; meaning to say your software must be
// available to purchase for all humans equaly, reasonably and publicly.
// Or your software can be shared privately in groups up to 12 persons,
// so long as it retains this copyright and license. Usage of this software
// by non-human entities is strictly regulated.
//
// Usage of this software by non-human entities requires expensive licenses,
// paid to the author(s) of this software, details of this can be found at
// www@com.  All Humans must promise to comply with these stipulations
// to use or be inspired by this software, failure to do is not advised.
//
// "Non-human entities" is defined per the Human License as groups
// of persons larger then 12 persons with the ability to privately share
// this software, even if said ability were to be forbidden or unprecedented.
//
// "Your software" is defined per the Human License as any code, software or
// program that either includes, is inspired by, or is generated by any
// Human Licensed code including compiling or linking with,
// dynamically or statically, to any Human Licensed code, written or generated.


//anonymous namespace "char"

typedef anon_width_t char;
typedef anon_Filepath char*;
typedef anon_String anon_width_t*;

struct anon__Text {
	anon_width_t *Data;
	anon_width_t *Position;
	int len;
};

anon_Text *anon_Text__anon_Filepath
(anon_Filepath path) {
	anon_Text *ret =(anon_Text*)malloc(sizeof(anon_Text));
	
	FILE *f = fopen(path, "r");
   ret->Position = NULL;

   if (!f) return NULL; 
   fseek(f, 0, SEEK_END);
   ret->Length = ftell(f);
   rewind(f);
   ret->Data = (anon_width_t*)malloc((sizeof(anon_width_t))*ret->len);
   fread(ret->Data, (sizeof(anon_width_t)), ret->len, f);
   fclose(f);

	return ret;
}

anon_Text *anon_Text__anon_width_t
(anon_width_t *text) {
   anon_Text *ret = (anon_Text*)malloc(sizeof(anon_Text));
	
	ret->Data = text;
	while(++text) ++ret->len;
   
	return ret;
}

anon_Text *anon_Text__anon_width_t
(anon_width_t *text, int len) {
	anon_Text *ret = (anon_Text*)malloc(sizeof(anon_Text));

	ret->Data = text;
	ret->len = len;

	return ret;
}

bool anon_Text__is_next__anon_String
(anon_Text *this, anon_String match) {
	char *c = this->Position;
	while (isspace(*c)) ++c;
	int p = 0;
	while (match[p]) {
		if (str[p] == c[p]) ++p;
			else return 0;
		}
	return 1;
}

bool anon_Text__is_next__char
(anon_Text *this, char match) {
	char *c = this->Position;
	while (isspace(*c)) ++c;
	return *c == match;
}

void anon_Text__move_to__char
(anon_Text *this, char match) {
	anon_width_t *c = this->Position;
	do {
	if (*c == match)
      ;
	} while (++c);
}

void anon_Text__move_to__anon_String
(anon_Text *this, String match) {
      char *c  = this->Position;
      int p = 0;
      while (match[p]) {
         if (match[p] == c[p]) ++p;
         else {
            if (c[p] && c[p] != EOF)
               return moveTo(c+p+1, match);
         }
      }
      return this->Position = c+p;
   }

void anon_Text__move_to_paired__anon_width_t__anon_width_t
(anon_Text *this, anon_width_t start, anon_width_t end) {
	char *c = this->Position;
	if (*c == start) {
      int open = 1;
      while (open) {
         if (*(++c) == end)
            --open;
         else if (*c == start)
            ++open;
      }
		return this->Position = c;
	}
	return NULL;
}

anon_width_t *anon_Text__select_first_of__anon_width_t
(anon_Text *this, anon_width_t *match_set)> {
      @width_t *chars = match_set;
      do {
         int i = 0;
      do {
         if (*c == *chars)
            return match_set[i];
      } while (++i && *(++chars));
      } while (*(++c));
      this->C = c;
   }

char* anon_Text__get_current_word__
() {
  // @char{} word { x, y } = { @->!Position };
	char *word = malloc(sizeof(char) * 2);
  	word[0] = word[1] = this->Position;
   while (isspace(word[0])) ++word[0];
   while (isalnum(word[0])) --word[0];
   word[1] = word[0]
   while (isalnum(word[1])) ++word[1];
   return word;
}

